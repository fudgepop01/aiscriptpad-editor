# aiscriptpad-editor README

This is an extension developed to assist in the editing of files generated by
[AIScriptPad](https://www.dropbox.com/s/pclv5x1vmk8o6fh/AIScriptPad2.0PM.zip?dl=0),
a separate program created/modified by `Mr. AI | Sluigi123`, and `Bero`.

**The Supported File Types Include:**
- `.as`
- `.aipd`
- `.atkd`

This extension adds the following features to vscode when editing those files:

- reading configuration from a given `include` folder
  - this can be configured in settings
  - defaults to `[current workspace root]/Include` as `./Include`
- autocompletion with argument support and documentation
- hover documentation
- jump to referenced label
  - done by ctrl+clicking on `Seek` or `Goto` instructions
- syntax highlighting

## As of [0.2.0], this Extenison ALSO adds...

the ability to compile and export the scripts! **(WINDOWS ONLY)**

Open the command panel with `Ctrl+Shift+P` and choose "export data from pac file"
to extract the AI files from a pac file, and choose "compile AI to pac file"
to compile the AI files back into the pac file.

alternatively, you can right click on a folder or pac file and choose the command from
the bottom of that menu!

## [0.3.0] - Macros, Globals, Named Variables/Constants, and Helper Functions!

So yeah I added a preprocessor. It's important to note that a `__preprocessed` folder will
now be created whenever scripts are compiled. This is to assist with debugging.

### Named Variables/Constants

Lets start with named variables / constants:

to assign a name to a variable, you can use the following format:

`#let varName = var4`

this allows you to use `varName` at a *later point in the code* and have it automatically
replaced by the variable you assigned it to when it comes time to compile. This makes things
significantly more readable.

so, after defining `varName` like that, any `varName` will be replaced with `var4`.

Constants are similar, except they get replaced by a value instead of a numbered variable

`#const my_constant = 69`

this will replace all instances of `my_constant` with `69` whenver it's used later on in the code.

You can also redeclare these with the same format if you really want to, but it's not recommended.

### Globals

Globals are just global named constants and variable names that you can define if you so desire.

Just make a `globals.as` file and put all your `#let` and `#define` statements in there. Then you
can use them in the other `.as` files without needing to redeclare them.

### Macros

Macros are just reusable pieces of code. They are **all defined in one** `macros.as`
**file** that's placed in the same place as all the other files. They start with `#macro macro_name`
and end with `#endmacro`

Here's one example that also uses named variables:

```
/*
  calculates the distance from the target position

  expects the following:
    var9 = targetXOffset
    var10 = targetYOffset
    var11 = targetXRange
    var12 = targetYRange
  modifies the following:
    var13, var14
  defines the following:
    targetXDistance (var13)
    targetYDistance (var14)
*/
#macro CALC_TARGET_DISTANCES() // the () was added in 0.4.0
  #let targetXOffset = var9
  #let targetYOffset = var10
  #let targetXRange = var11
  #let targetYRange = var12
  DrawDebugPoint TopNX TopNY 255 0 0 255

  #let targetX = var13
  #let targetY = var14
  targetX = OTopNX + (targetXOffset * Direction * -1)
  targetY = OTopNY + targetYOffset
  // account for target's & own velocity
  targetX = targetX + (OXSpeed * 10) - (XSpeed * 7)
  targetY = targetY + (OYSpeed * 4) - (YSpeed * 4)
  DrawDebugRectOutline targetX targetY targetXRange targetYRange 0 255 0 255

  #let targetXDistance = var13
  #let targetYDistance = var14
  targetXDistance = targetX - TopNX
  targetYDistance = targetY - TopNY
#endmacro
```

In other files, whenever a line consisting exclusively of `CALC_TARGET_DISTANCES` is encountered,
it will be replaced by the contents of that macro. This will *also* declare/redeclare any
variable names and constants that were used inside that macro, so after using the macro in
another file, you can also use `targetXDistance` and `targetYDistance` (and the others, but
those `targetXDistance` and `targetYDistance` are the important ones)

### Helper "Functions"

there are a few things you can surround certain kinds of values with to convert them to a
numeric or argument equivalent:

- `color(0x[hex value here])`
  - converts a hex value to a series of four values 0 through 255 representing red, green, blue, and alpha
- `str("[string here]")`
  - converts a string to a series of 5 numbers representing the text. Every 3 characters is 1 value.
- `strv("[string here]")`
  - converts a string of 3 characters **OR LESS** to a single number representing that text
- `hex(0x[hex value here])`
  - converts a hex number to a standard number. This is necessary if you want to use a hex value representation
    of a number in your source code.

## [0.4.0] - Templated Macros

Macros can now take arguments! That means you can make them do things like use different variables
or even inline values! As such, **the syntax for defining macros has changed slightly since 0.3.0**:

Here is how you can define and use a macro with templated parameters:

```
#macro TEMPLATED_MACRO(var1, amount)
  #let tempVar = {var1}

  // do stuff with tempVar
#endmacro
```

> **NOTE:**
>
> It is important that you don't get *too* carried away and start treating macros like
> standard functions! Each time you use a macro the full text is inserted. They were mainly made
> to allow users to make use of all 10 "local" variables rather than make some convoluted system
> involving lots of consistency.

Anyway, enjoy!

## [0.5.0] - Template Files & Snippets

Now you have the ability to create and read from a folder named `shared` in the `include` directory!
What this means is you're now able to define multiple things across multiple projects *including* code.
For macros and globals, simply make `macros.as` and `globals.as` files within the `shared` directory. 
For code, create a `templates` folder inside the `shared` folder and add whatever `.as` files you want to
share across all projects.

These template files can include things called `snippets` - they're basically the same thing as macros but 
they're special. They take *no* arguments and are used inside the template files with `{TEMPLATE_NAME}`.
To fill in these templates on a per-project basis, make a file of the same name within the project's directory.
Here, you'll create a `TEMPLATE_NAME` snippet with `#snippet` and `#endsnippet`.

in this case it would be:

```
#snippet TEMPLATE_NAME
  // whatever code you want here
#endsnippet
```

Even if you have template files, you can override them by just structuring a file of the same name as you normally would.
(The key part it searches for is any line starting with `id `).

Furthermore, any constants and macros defined in the shared `globals.as` and `macros.as` can be overwritten in a similar way.
Just make a constant / macro of the same name and it'll automatically be overwritten!

## [0.6.0] - Custom Preprocessor Scripts!

Now you can create your own custom preprocessing functions! 

Make a file named `scripts.js` in the same place as `globals.as` and `macros.as` in the *shared* folder. In here you can create functions just as you normally would with javascript. Anything you want to use as a preprocessor function should be prefaced with the `export` keyword. 

All parameters recieved will be of javascript type `string`. These functions should return a string. This return value will automatically be preprocessed - so no worries there. 

```js
export const testFunc = () => {
  return `// this is the output of testFunc`;
}

export function argFunc(arg1) {
  return `// you passed in: "${arg1}"`;
}
```

You can access globally defined constants with a special `$globals` variable. This contains all the constants as key/value pairs, where the key is the constant name and the value is the constant value. The following will list out each defined global as well as its value in a line comment:

```js
export const listGlobals = () => {
  let out = "";
  for (const [key, val] of Object.entries($globals)) {
    out += `// ${key}: ${val}\n`;
  }
  return out;
}
```

Once defined, you can call the function with `$function_name_here()`. Ex.

```
$testFunc()

$argFunc(hello world)
```

will get transformed into the following when you compile it:

```
// this is the output of testFunc

// you passed in "hello world"
```

Use this to automate certain tasks that would otherwise be extremely tedious!